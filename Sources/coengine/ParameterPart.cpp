/*****************************************************************************
 *$Workfile: ParameterPart.cpp $
 *$Revision: 19 $
 *$Modtime: 12/14/00 1:47p $
 *$Author: Lw $
 ******************************************************************************
 *
 *	COPYRIGHT (C) 1999 CGI NEDERLAND B.V. - ALL RIGHTS RESERVED
 *
 ******************************************************************************/
#pragma warning(disable:4786)

#include "ParameterPart.h"			// Class definition

#include <iomanip>
#include <sstream>
#include <string>

using namespace std;

#include "ActionWordList.h"
#include "ComposedInterpreter.h"	// Composition class definition
#include "EngineSetting.h"			// EngineSetting definition
#include "Interpreter.h"			// Baseclass definition
#include "Parser.h"					// Parser definition
#include "AnythingCommand.h"		// AnythingCommand class definition
#include "KeepCommand.h"			// KeepCommand class definition
#include "SnapCommand.h"			// SnapCommand class definition
#include "EmptyCommand.h"			// EmptyCommand class definition
#include "NotEmptyCommand.h"		// NotEmptyCommand class definition
#include "SpacesCommand.h"			// SpacesCommand class definition
#include "ExpressionCommand.h"		// ExpressionCommand class definition
#include "DateCommand.h"			// DateCommand class definition
#include "TimeCommand.h"			// TimeCommand class definition
#include "ReferCommand.h"			// ReferCommand class definition


#define BASECLASS Interpreter;

///////////////////////////////////////////////////////////////////////////////
// Construction and destruction

// Default constructor
ParameterPart::ParameterPart()
{
	SetTheParser(new Parser());

	m_pAnythingCommand		= new AnythingCommand();
	m_pKeepCommand			= new KeepCommand(m_pTheParser);
	m_pSnapCommand			= new SnapCommand();
	m_pEmptyCommand			= new EmptyCommand();
	m_pNotEmptyCommand		= new NotEmptyCommand();
	m_pSpacesCommand		= new SpacesCommand(m_pTheParser);
	m_pExpressionCommand	= new ExpressionCommand(m_pTheParser);
	m_pReferCommand			= new ReferCommand(m_pTheParser);
	m_pDateCommand			= new DateCommand(m_pTheParser);
	m_pTimeCommand			= new TimeCommand(m_pTheParser);

}

// Destructor
ParameterPart::~ParameterPart()
{
	delete m_pTheParser;
	delete m_pAnythingCommand;
	delete m_pKeepCommand;		
	delete m_pSnapCommand;		
	delete m_pEmptyCommand;		
	delete m_pNotEmptyCommand;	
	delete m_pSpacesCommand;	
	delete m_pExpressionCommand;
	delete m_pReferCommand;
	delete m_pDateCommand;
	delete m_pTimeCommand;

	m_pTheParser=0;
	m_pAnythingCommand=0;
	m_pKeepCommand=0;		
	m_pSnapCommand=0;		
	m_pEmptyCommand=0;		
	m_pNotEmptyCommand=0;	
	m_pSpacesCommand=0;	
	m_pExpressionCommand=0;
	m_pReferCommand=0;
	m_pDateCommand=0;
	m_pTimeCommand=0;
}

///////////////////////////////////////////////////////////////////////////////
// Attributes and operations

//						========================
bool					ParameterPart::Interpret 
//						========================
(
	const string&		strParameter
)
{
	bool	bResult;				// interpretation result
	string	strArgumentValue;		// result of the evaluation
	int		nType = LITERAL;		// parameter type, default LITERAL

	// check if the line is not a comment line
	if (GetTheComposedInterpreter()->GetActionType() != ActionWordList::EMPTY)
	{
		// check if argument is anything other than a literal

		// check if argument is not empty
		if (!strParameter.empty())
		{
			// check if the argument is a command
			nType = DetermineCommandType(strParameter);
		}
	}

	// Store parametertype
	m_nParameterType = nType;

	// Initialise result as ok
	bResult = true;

	// Perform action associated with parametertype
	switch (nType)
	{
		case (REFER):
		{
			bResult = m_pReferCommand->Interpret(strParameter);
			strArgumentValue = m_pReferCommand->GetArgumentValue();
			break;
		}

		case (EXPRESSION) :
		{
			bResult = m_pExpressionCommand->Interpret(strParameter);
			strArgumentValue = m_pExpressionCommand->GetArgumentValue();
			break;
		}

		case (KEEP):
		{
			// Keep variable found, interpret and add name to keep list
			bResult = m_pKeepCommand->Interpret(strParameter);
			strArgumentValue = m_pKeepCommand->GetArgumentValue();
			if (bResult)
			{
				// only add the Keep name when no errors generated by Interpret
				GetTheComposedInterpreter()->AddKeepName(m_pKeepCommand->GetParameterString());
			}
			break;
		}

		case (TIME)		:
		{
			bResult = m_pTimeCommand->Interpret(strParameter);
			strArgumentValue = m_pTimeCommand->GetArgumentValue();
			break;
		}

		case (DATE)		:
		{
			bResult = m_pDateCommand->Interpret(strParameter);
			strArgumentValue = m_pDateCommand->GetArgumentValue();
			break;
		}
		
		case (SPACES)	:
		{
			bResult = m_pSpacesCommand->Interpret(strParameter);
			strArgumentValue = m_pSpacesCommand->GetArgumentValue();
			break;
		}

		case (EMPTY)	:
		{
			bResult = m_pEmptyCommand->Interpret(strParameter);
			strArgumentValue = m_pEmptyCommand->GetArgumentValue();
			break;
		}

		case (SNAP)		:
		{
			// Snap command found, interpret and add name to snap list
			bResult = m_pSnapCommand->Interpret(strParameter);
			strArgumentValue = m_pSnapCommand->GetArgumentValue();
			if (bResult)
			{
				// only add the Snap name when no errors generated by Interpret
				GetTheComposedInterpreter()->AddSnapName(m_pSnapCommand->GetParameterString());
			}
			break;
		}

		case (NOTEMPTY)	:
		{
			// NotEmpty command found, same as default
			bResult = m_pNotEmptyCommand->Interpret(strParameter);
			strArgumentValue = m_pNotEmptyCommand->GetArgumentValue();
			break;
		}
		case (ANYTHING)	:
		{
			// Anything command found; same as default
			bResult = m_pAnythingCommand->Interpret(strParameter);
			strArgumentValue = m_pAnythingCommand->GetArgumentValue();
			break;
		}
		case (LITERAL)	:
			// Literal found, same as default
		default	:
		{
			// Insert the unevaluated parameter in parameterlist
			strArgumentValue = strParameter;
			bResult = true;
			break;
		}
	}
	GetTheComposedInterpreter()->AddParameter(strArgumentValue);

	// NOTE etb : An error is only generated when a expression evaluation results 
	//			  in error otherwise its a literal
	return bResult;
}

//						===============================
const vector<string>&	ParameterPart::GetErrorVector() const
//						===============================
{
	// Delegate to parser
	return m_pTheParser->GetErrorVector(); 
}

//						=========================
void					ParameterPart::SetContext
//						=========================
(
	Context*			pContext
)
{ 
	// Delegate to parser
	m_pTheParser->SetContext(pContext); 
}

//						=========================
void					ParameterPart::Initialise
//						=========================
(
	EngineSetting*		pSetting
)
{
	// Initialise the parameterpart
	GetTheParser()->Initialise(pSetting);

	m_pAnythingCommand->Initialize(pSetting);
	m_pKeepCommand->Initialize(pSetting);
	m_pSnapCommand->Initialize(pSetting);
	m_pEmptyCommand->Initialize(pSetting);
	m_pNotEmptyCommand->Initialize(pSetting);
	m_pSpacesCommand->Initialize(pSetting);
	m_pExpressionCommand->Initialize(pSetting);
	m_pReferCommand->Initialize(pSetting);
	m_pDateCommand->Initialize(pSetting);
	m_pTimeCommand->Initialize(pSetting);

	// create the vector with command types in the correct evaluation order
	CreateCommandEvalOrder();
}


///////////////////////////////////////////////////////////////////////////////
// Implementation

//						=====================================
void					ParameterPart::CreateCommandEvalOrder()
//						=====================================
{
	// create a vector of command types with associated prefix lengths
	vector<pair<int, int> > vprnCommands;

	// add all commands to vector of pairs
	AddCommandToEvalOrder(REFER,		m_pReferCommand->GetPrefixLength(), vprnCommands);
	AddCommandToEvalOrder(EXPRESSION,	m_pExpressionCommand->GetPrefixLength(), vprnCommands);
	AddCommandToEvalOrder(KEEP,			m_pKeepCommand->GetPrefixLength(),		 vprnCommands);
	AddCommandToEvalOrder(SNAP,			m_pSnapCommand->GetPrefixLength(),		 vprnCommands);
	AddCommandToEvalOrder(SPACES,		m_pSpacesCommand->GetPrefixLength(),	 vprnCommands);
	AddCommandToEvalOrder(TIME,			m_pTimeCommand->GetPrefixLength(),		 vprnCommands);
	AddCommandToEvalOrder(DATE,			m_pDateCommand->GetPrefixLength(),		 vprnCommands);
	AddCommandToEvalOrder(EMPTY,		m_pEmptyCommand->GetPrefixLength(),		 vprnCommands);
	AddCommandToEvalOrder(NOTEMPTY,		m_pNotEmptyCommand->GetPrefixLength(),	 vprnCommands);
	AddCommandToEvalOrder(ANYTHING,		m_pAnythingCommand->GetPrefixLength(),	 vprnCommands);

	// fill the vector of ordered commands with those we just found
	m_vnCommandsInEvalOrder.clear();
	int nSize = vprnCommands.size();
	for (int i = 0; i < nSize; i++)
	{
		m_vnCommandsInEvalOrder.push_back(vprnCommands[i].first);
	}
}


//						====================================
void					ParameterPart::AddCommandToEvalOrder
//						====================================
(
	int					nCommandType,			// command type to be placed in vector
	int					nCommandPrefixLength,	// command prefix length
	vector<pair<int, int> >&	vprnCommands	// pointer to vector of command type-
												// prefix length pairs
)
{
	pair<int, int> prnCommandPair(nCommandType, nCommandPrefixLength);	// pair to add

	// check if vector is empty
	if (vprnCommands.empty())
	{
		// add command pair to vector
		vprnCommands.push_back(prnCommandPair);
	}
	else
	{
		// determine the index of the vector before which the pair should be added
		int nIndex = IndexInCommandVector(nCommandPrefixLength, vprnCommands);

		// check if the command should not be inserted in the vector, but added to
		// the back
		if (nIndex == -1)
		{
			// add to the back of the vector
			vprnCommands.push_back(prnCommandPair);
		}
		else
		{
			// insert in the vector
			vprnCommands.insert(vprnCommands.begin() + nIndex, prnCommandPair);
		}
	}
}


//						===================================
int						ParameterPart::IndexInCommandVector
//						===================================
(
	int					nCommandPrefixLength,		// command prefix length
	const vector<pair<int, int> >&	vprnCommands	// vector of command type-
													// prefix length pairs
)
{
	int		nIndex 	= -1;						// index to return
	int		nSize	= vprnCommands.size();		// size of vector
	bool	bReady	= false;					// index found

	for (int i = 0; i < nSize && !bReady ; i++)
	{
		// determine the prefix length of the i-th element
		int nCurrentLength = vprnCommands[i].second;

		if (nCommandPrefixLength > nCurrentLength)
		{
			nIndex = i;
			bReady = true;
		}
	}

	return nIndex;
}


//						===================================
int						ParameterPart::DetermineCommandType
//						===================================
(
	const string&		strArgument			// argument to scan for command
)
{
	int nCommandType = LITERAL;		// command type to return

	// determine number of commands
	int nCommands = m_vnCommandsInEvalOrder.size();
	bool bCommandFound = false;		// states if a command is found

	// scan the specified argument for commands in the order as specified in the
	// vector m_vnCommandsInEvalOrder
	for (int i = 0; i < nCommands && !bCommandFound; i++)
	{
		// check if the argument contains the command which is next in the vector
		switch (m_vnCommandsInEvalOrder[i])
		{
			case (EXPRESSION):
			{
				// check if the argument is an expression command
				if (m_pExpressionCommand->IsCommand(strArgument))
				{ 
					nCommandType	= EXPRESSION;
					bCommandFound	= true;
				}
				break;
			}
			case (REFER):
			{
				// check if the argument is an refer command
				if (m_pReferCommand->IsCommand(strArgument))
				{ 
					nCommandType	= REFER;
					bCommandFound	= true;
				}
				break;
			}

			case (KEEP):
			{
				// check if the argument is a keep command
				if (m_pKeepCommand->IsCommand(strArgument))
				{ 
					nCommandType	= KEEP;
					bCommandFound	= true;
				}
				break;
			}

			case (SNAP):
			{
				// check if the argument is a snap command
				if (m_pSnapCommand->IsCommand(strArgument))
				{ 
					nCommandType	= SNAP;
					bCommandFound	= true;
				}
				break;
			}

			case (SPACES):
			{
				// check if the argument is a spaces command
				if (m_pSpacesCommand->IsCommand(strArgument))
				{ 
					nCommandType	= SPACES;
					bCommandFound	= true;
				}
				break;
			}

			case (TIME):
			{
				// check if the argument is a time command
				if (m_pTimeCommand->IsCommand(strArgument))
				{ 
					nCommandType	= TIME;
					bCommandFound	= true;
				}
				break;
			}

			case (DATE):
			{
				// check if the argument is a date command
				if (m_pDateCommand->IsCommand(strArgument))
				{ 
					nCommandType	= DATE;
					bCommandFound	= true;
				}
				break;
			}

			case (EMPTY):
			{
				// check if the argument is a Empty command
				if (m_pEmptyCommand->IsCommand(strArgument))
				{ 
					nCommandType	= EMPTY;
					bCommandFound	= true;
				}
				break;
			}

			case (NOTEMPTY):
			{
				// check if the argument is a NotEmpty command
				if (m_pNotEmptyCommand->IsCommand(strArgument))
				{ 
					nCommandType	= NOTEMPTY;
					bCommandFound	= true;
				}
				break;
			}

			case (ANYTHING):
			{
				// check if the argument is an anything command
				if (m_pAnythingCommand->IsCommand(strArgument))
				{ 
					nCommandType	= ANYTHING;
					bCommandFound	= true;
				}
				break;
			}
		}
	}
	
	return nCommandType;
}


